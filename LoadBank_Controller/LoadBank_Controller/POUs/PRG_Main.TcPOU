<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.16">
  <POU Name="PRG_Main" Id="{f4e4631f-475c-4b5d-8b5a-6d568c70cda9}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM PRG_Main
VAR
    // ============================================
    // FUNCTION BLOCK INSTANCES
    // ============================================
    Single_Fan              : FB_Single_Fan;
    Temperature_Monitor     : FB_Temperature_Monitor;
    Gradual_Dump            : FB_Gradual_Dump;
    Main_Contactor          : FB_Main_Contactor;
    Load_Controller         : FB_Load_Controller;
    Mode_Manager            : FB_Mode_Manager;
    DataLogger              : FB_DataLogger;
    Alarm_Manager           : FB_Alarm_Manager;
    
    // Mode FBs
    Auto_Mode               : FB_Auto_Mode;
    Numeric_Mode            : FB_Numeric_Mode;
    Reverse_Mode            : FB_Reverse_Mode;
    Manual_Mode             : FB_Manual_Mode;
    Recipe_Controller       : FB_Recipe_Controller;
    Maintenance_Mode        : FB_Maintenance_Mode;
    
    // Recipe Storage
    Recipe_Storage          : FB_Recipe_Storage_Manager;
    
    // ============================================
    // EMERGENCY STOP (internal)
    // ============================================
    EMG_Immediate_Active    : BOOL;
    EMG_Controlled_Active   : BOOL;
    Any_Emergency           : BOOL;
    
    // ============================================
    // ALARM RESET (internal)
    // ============================================
    Alarm_Reset_Combined    : BOOL;
    Alarm_Reset_Prev        : BOOL;
    Alarm_Reset_Pulse       : BOOL;
    
    // ============================================
    // INTERNAL
    // ============================================
    i                       : UINT;
    First_Scan              : BOOL := TRUE;
    
    // ============================================
    // FIX: Local TC buffer to convert [1..2] â†’ [1..4]
    // ============================================
    Temp_TC_Buffer          : ARRAY[1..4] OF REAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
// ============================================================
// FIRST SCAN INITIALIZATION
// ============================================================
IF First_Scan THEN
    HMI_Master_Enable := FALSE;
    HMI_Fan_Start := FALSE;
    Master_Enable_Was_Off := TRUE;
    Fan_Start_Was_Off := TRUE;
    First_Scan := FALSE;
END_IF;

// ============================================================
// EMERGENCY STOP DETECTION (NC contacts - TRUE = OK)
// ============================================================
EMG_Immediate_Active := NOT IO_Emergency_Immediate;
EMG_Controlled_Active := NOT IO_Emergency_Controlled;
Any_Emergency := EMG_Immediate_Active OR EMG_Controlled_Active;

// ============================================================
// ALARM RESET (rising edge detection)
// ============================================================
Alarm_Reset_Combined := Alarm_Reset_Cmd OR HMI_Reset_Cmd;
Alarm_Reset_Pulse := Alarm_Reset_Combined AND NOT Alarm_Reset_Prev;
Alarm_Reset_Prev := Alarm_Reset_Combined;

// Clear HMI reset command after processing
IF HMI_Reset_Cmd THEN
    HMI_Reset_Cmd := FALSE;
END_IF;

// ============================================================
// FIX: COPY TC READINGS INTO [1..4] BUFFER
// ============================================================
Temp_TC_Buffer[1] := IO_Temperature_TC[1];
Temp_TC_Buffer[2] := IO_Temperature_TC[2];
Temp_TC_Buffer[3] := 0.0;
Temp_TC_Buffer[4] := 0.0;

// ============================================================
// TEMPERATURE MONITOR
// ============================================================
Temperature_Monitor(
    Outlet_TC_Readings := Temp_TC_Buffer,
    Inlet_TC_Reading := IO_Temperature_Inlet,
    Outlet_TC_Count := LB_NUMBER_OF_TCS,
    Inlet_TC_Enabled := LB_INLET_TC_ENABLED,
    Outlet_Warning_Temp := LB_OUTLET_WARNING_TEMP,
    Outlet_Maximum_Temp := LB_OUTLET_MAXIMUM_TEMP,
    TC_Open_Limit := LB_TC_OPEN_LIMIT,
    TC_Short_Limit := LB_TC_SHORT_LIMIT,
    Inlet_Warning_Temp := LB_INLET_WARNING_TEMP,
    Inlet_Maximum_Temp := LB_INLET_MAXIMUM_TEMP,
    Enable := TRUE,
    Reset := Alarm_Reset_Pulse
);

// Update status
Status_Temperature := Temperature_Monitor.Status_Text;
LB_System_Status.Temperature_Outlet_Avg := Temperature_Monitor.Outlet_Temp_Avg;
LB_System_Status.Temperature_Outlet_Max := Temperature_Monitor.Outlet_Temp_Max;
LB_System_Status.Temperature_Inlet := Temperature_Monitor.Inlet_Temp;
LB_System_Status.Temperature_DeltaT := Temperature_Monitor.Delta_T;
LB_System_Status.Hottest_TC_Number := Temperature_Monitor.Hottest_TC_Index;

// HMI temperature status
IF Temperature_Monitor.Any_Overtemp THEN
    LB_HMI_Temperature_Status := 2;
ELSIF Temperature_Monitor.Any_Warning THEN
    LB_HMI_Temperature_Status := 1;
ELSE
    LB_HMI_Temperature_Status := 0;
END_IF;

// ============================================================
// GRADUAL DUMP
// ============================================================
Gradual_Dump(
    Temp_Dump_Trigger := Temperature_Monitor.Dump_Command,
    EMG_Dump_Trigger := EMG_Controlled_Active,
    Current_Power_kW := Load_Controller.Released_Power_kW,
    Rated_Power_kW := Load_Controller.Rated_Total_kW,
    EMG_Percent_Per_Step := LB_EMG_DUMP_PERCENT,
    EMG_Step_Time := LB_EMG_DUMP_STEP_TIME,
    Temp_Percent_Per_Step := LB_TEMP_DUMP_PERCENT,
    Temp_Step_Time := LB_TEMP_DUMP_STEP_TIME,
    Dump_Timeout := LB_DUMP_TIMEOUT,
    Enable := TRUE,
    Reset := Alarm_Reset_Pulse
);

// Update runtime variables
Dump_Active := Gradual_Dump.Dump_Active;
Dump_Complete := Gradual_Dump.Dump_Complete;
Dump_Percent := Gradual_Dump.Dump_Percent;
Is_Temperature_Dump := Gradual_Dump.Is_Temperature_Dump;
Is_Emergency_Dump := Gradual_Dump.Is_Emergency_Dump;
Status_Dump := Gradual_Dump.Status_Text;

// ============================================================
// ALARM MANAGER
// ============================================================
Alarm_Manager(
    IN_Emergency_Immediate := EMG_Immediate_Active,
    IN_Emergency_Controlled := EMG_Controlled_Active,
    IN_Temp_Overtemp := Temperature_Monitor.Any_Overtemp,
    IN_Temp_Warning := Temperature_Monitor.Any_Warning,
    IN_TC_Sensor_Fail := Temperature_Monitor.TC_Fail_Dump_Required,
    IN_Inlet_Overtemp := Temperature_Monitor.Inlet_TC_Overtemp AND LB_INLET_TC_ENABLED,
    IN_Inlet_TC_Fail := Temperature_Monitor.Inlet_TC_Fail AND LB_INLET_TC_ENABLED,
    IN_TC_Contingency := Temperature_Monitor.Contingency_Mode,
    IN_Fan_Motor_Overload := Single_Fan.Fault_Motor_Overload,
    IN_Fan_Pressure_Fail := Single_Fan.Fault_Pressure,
    IN_Fan_Contactor_Fail := Single_Fan.Fault_Contactor,
    IN_Main_Contactor_Fail := Main_Contactor.Contactor_Fault,
    IN_Step_Feedback_Fault := Load_Controller.Any_Feedback_Fault,
    IN_Power_Mismatch := Load_Controller.Total_Power_Warning,
    IN_Dump_Timeout := Gradual_Dump.Dump_Timeout_Fault,
    IN_Voltage_Imbalance := Voltage_Imbalance_Warning,
    IN_Current_Imbalance := Current_Imbalance_Warning,
    RTC_Valid := FALSE,
    Acknowledge_Alarm := HMI_Alarm_Acknowledge,
    Acknowledge_All_Cmd := HMI_Alarm_Acknowledge_All,
    Reset_Cmd := Alarm_Reset_Pulse,
    Clear_History_Cmd := HMI_Alarm_Clear_History,
    Enable := TRUE
);

// Copy Alarm Manager outputs to GVL
General_Alarm := Alarm_Manager.General_Alarm;
General_Warning := Alarm_Manager.General_Warning;
System_Normal := Alarm_Manager.System_Normal;
Any_Fault_Active := Alarm_Manager.Any_Fault_Active;

// LED outputs
IO_LED_General_Alarm := Alarm_Manager.LED_Alarm;
IO_LED_Warning := Alarm_Manager.LED_Warning;
IO_LED_System_Normal := Alarm_Manager.LED_Normal;

// Alarm list and counts for HMI
LB_Alarm_List := Alarm_Manager.Alarm_List;
LB_Alarm_List_Count := Alarm_Manager.Alarm_List_Count;
LB_Alarm_History := Alarm_Manager.Alarm_History;
LB_Alarm_History_Count := Alarm_Manager.History_Count;

LB_Critical_Alarm_Count := Alarm_Manager.Critical_Alarm_Count;
LB_Warning_Count := Alarm_Manager.Warning_Count;
LB_Total_Alarm_Count := Alarm_Manager.Total_Active_Count;
LB_Unacknowledged_Count := Alarm_Manager.Unacknowledged_Count;

LB_New_Alarm_Trigger := Alarm_Manager.New_Alarm_Trigger;
LB_Newest_Alarm_ID := Alarm_Manager.Newest_Alarm_ID;
LB_Newest_Alarm_Name := Alarm_Manager.Newest_Alarm_Name;

// ============================================================
// MASTER ENABLE CONTROL
// ============================================================
IF General_Alarm THEN
    HMI_Master_Enable := FALSE;
    Master_Enable_Blocked := TRUE;
END_IF;

IF LB_ENABLE_PHYSICAL_MASTER THEN
    IF NOT IO_Physical_Master_Enable THEN
        Master_Enable_Was_Off := TRUE;
    END_IF;
    
    IF NOT General_Alarm AND Master_Enable_Was_Off AND NOT IO_Physical_Master_Enable THEN
        Master_Enable_Blocked := FALSE;
    END_IF;
    
    IF IO_Physical_Master_Enable THEN
        Master_Enable_Was_Off := FALSE;
    END_IF;
    
    Master_Enable := (HMI_Master_Enable OR IO_Physical_Master_Enable) 
                     AND NOT Master_Enable_Blocked
                     AND NOT General_Alarm;
ELSE
    IF NOT General_Alarm AND Master_Enable_Was_Off THEN
        Master_Enable_Blocked := FALSE;
    END_IF;
    
    Master_Enable := HMI_Master_Enable AND NOT General_Alarm;
END_IF;

// ============================================================
// FAN CONTROL
// ============================================================
IF Single_Fan.Fan_Fault THEN
    HMI_Fan_Start := FALSE;
    Fan_Start_Blocked := TRUE;
END_IF;

IF LB_ENABLE_PHYSICAL_FAN THEN
    IF NOT IO_Physical_Fan_Start THEN
        Fan_Start_Was_Off := TRUE;
    END_IF;
    
    IF NOT Single_Fan.Fan_Fault AND Fan_Start_Was_Off AND NOT IO_Physical_Fan_Start THEN
        Fan_Start_Blocked := FALSE;
    END_IF;
    
    IF IO_Physical_Fan_Start THEN
        Fan_Start_Was_Off := FALSE;
    END_IF;
    
    Fan_Start_Command := (HMI_Fan_Start OR IO_Physical_Fan_Start)
                         AND NOT Fan_Start_Blocked;
ELSE
    IF NOT Single_Fan.Fan_Fault AND Fan_Start_Was_Off THEN
        Fan_Start_Blocked := FALSE;
    END_IF;
    
    Fan_Start_Command := HMI_Fan_Start AND NOT Fan_Start_Blocked;
END_IF;

// Call Single Fan FB (UPDATED - Added debounce and phase monitor inputs)
Single_Fan(
    HMI_Start := HMI_Fan_Start,
    Physical_Start := IO_Physical_Fan_Start,
    Physical_Enabled := LB_ENABLE_PHYSICAL_FAN,
    Contactor_Feedback := IO_Fan_Contactor_FB,
    Motor_Overload_OK := IO_Fan_Motor_Overload_OK,
    Pressure_OK := IO_Fan_Pressure_OK,
    Phase_Monitor_OK := IO_Phase_Monitor_OK,
    Phase_Monitor_Enabled := LB_ENABLE_PHASE_MONITOR,
    Debounce_Pressure := LB_DEBOUNCE_PRESSURE,
    Debounce_Contactor := LB_DEBOUNCE_CONTACTOR,
    Debounce_Overload := LB_DEBOUNCE_OVERLOAD,
    Emergency_Immediate := EMG_Immediate_Active,
    Emergency_Controlled := Is_Emergency_Dump,
    Is_Temperature_Dump := Is_Temperature_Dump,
    Dump_Complete := Dump_Complete,
    Pressurize_Time := LB_FAN_PRESSURIZE_TIME,
    Cooldown_Time := LB_FAN_COOLDOWN_TIME,
    Feedback_Timeout := LB_FAN_FEEDBACK_TIMEOUT,
    Post_Dump_Delay := LB_FAN_POST_DUMP_DELAY,
    Enable := Fan_Start_Command,
    Reset_Fault := Alarm_Reset_Pulse
);

// Copy cooldown status to HMI
LB_HMI_Fan_Cooldown_Active := Single_Fan.Cooldown_Active;
LB_HMI_Fan_Cooldown_Remaining := Single_Fan.Cooldown_Remaining;

// Update status
Status_Fan := Single_Fan.Status_Message;
LB_System_Status.Fan_Running := Single_Fan.Fan_Running;
LB_System_Status.Fan_Fault := Single_Fan.Fan_Fault;
LB_System_Status.Fan_Cycle_Count := Single_Fan.Cycle_Count;

// HMI fan status (UPDATED - Added cooldown state)
IF Single_Fan.Fan_Fault THEN
    LB_HMI_Fan_Status := 5;         // Fault
ELSIF Single_Fan.Cooldown_Active THEN
    LB_HMI_Fan_Status := 4;         // Cooling down
ELSIF Single_Fan.Fan_Running AND Single_Fan.Fan_Pressurized THEN
    LB_HMI_Fan_Status := 3;         // Running
ELSIF Single_Fan.Fan_Running AND NOT Single_Fan.Fan_Pressurized THEN
    LB_HMI_Fan_Status := 2;         // Pressurizing
ELSIF Single_Fan.Contactor_Output THEN
    LB_HMI_Fan_Status := 1;         // Starting
ELSE
    LB_HMI_Fan_Status := 0;         // Off
END_IF;

// ============================================================
// MAIN CONTACTOR
// ============================================================
Main_Contactor(
    Master_Enable := Master_Enable,
    Fan_Running := Single_Fan.Fan_Running,
    Fan_Pressurized := Single_Fan.Fan_Pressurized,
    Any_Alarm := General_Alarm,
    Dump_Active := Dump_Active,
    Dump_Complete := Dump_Complete,
    Is_Temperature_Dump := Is_Temperature_Dump,
    Contactor_Feedback := IO_Main_Contactor_FB,
    Feedback_Timeout := LB_MAIN_CONTACTOR_FB_TIMEOUT,
    Enable := TRUE,
    Reset := Alarm_Reset_Pulse
);

// Update status
Main_Contactor_Closed := Main_Contactor.Contactor_Closed;
Main_Contactor_Fault := Main_Contactor.Contactor_Fault;
Main_Contactor_Allowed := Main_Contactor.Contactor_Output;
Status_Main_Contactor := Main_Contactor.Status_Text;

// ============================================================
// SYSTEM STATUS
// ============================================================
System_Ready := Single_Fan.Fan_Running 
                AND Single_Fan.Fan_Pressurized 
                AND NOT General_Alarm
                AND Master_Enable;

System_Running := Main_Contactor_Closed 
                  AND Load_Controller.Active_Step_Count > 0;

System_Fault := General_Alarm;

LB_System_Status.System_Ready := System_Ready;
LB_System_Status.System_Running := System_Running;
LB_System_Status.System_Fault := System_Fault;

// HMI system status
IF System_Fault THEN
    LB_HMI_System_Status := 3;
ELSIF System_Running THEN
    LB_HMI_System_Status := 2;
ELSIF System_Ready THEN
    LB_HMI_System_Status := 1;
ELSE
    LB_HMI_System_Status := 0;
END_IF;

// ============================================================
// MODE MANAGER
// ============================================================
Mode_Manager(
    Mode_Select := HMI_Mode_Select,
    Master_Enable := Master_Enable,
    Emergency_Active := Any_Emergency,
    System_Ready := System_Ready
);

// Update status
Mode_Current := Mode_Manager.Active_Mode;
LB_HMI_Mode_Text := Mode_Manager.Mode_Name;
LB_HMI_Mode_Ready := Mode_Manager.Mode_Ready;

// ============================================================
// MODE EXECUTION - GET TARGET POWER
// ============================================================
Mode_Target_Power := 0.0;

CASE Mode_Manager.Active_Mode OF

    LB_MODE_OFF:
        Mode_Target_Power := 0.0;
        
    LB_MODE_AUTO_LEVELING:
        Auto_Mode(
            Mode_Active := TRUE,
            External_Power_kW := IO_External_Power_kW,
            Min_Load_kW := HMI_Min_Load_kW,
            Available_Power_kW := Load_Controller.Available_Power_kW,
            Deadband_kW := LB_AUTO_LEVEL_DEADBAND,
            System_Ready := System_Ready
        );
        Mode_Target_Power := Auto_Mode.Target_Power_kW;
        Auto_Mode_Power_Error := Auto_Mode.Power_Error;
        Auto_Mode_Status := Auto_Mode.Status_Text;
        
    LB_MODE_NUMERIC:
        Numeric_Mode(
            Mode_Active := TRUE,
            Target_Power_Setpoint := HMI_Target_Power_kW,
            Rated_Power_kW := Load_Controller.Rated_Total_kW,
            System_Ready := System_Ready
        );
        Mode_Target_Power := Numeric_Mode.Target_Power_kW;
        Numeric_Mode_Status := Numeric_Mode.Status_Text;
        
    LB_MODE_REVERSE_POWER:
        Reverse_Mode(
            Mode_Active := TRUE,
            Generator_Power_kW := IO_External_Power_kW,
            Follow_Percentage := HMI_Follow_Percentage,
            Max_Power_kW := Load_Controller.Available_Power_kW,
            System_Ready := System_Ready
        );
        Mode_Target_Power := Reverse_Mode.Target_Power_kW;
        Reverse_Mode_Target_Power := Reverse_Mode.Target_Power_kW;
        Reverse_Mode_Status := Reverse_Mode.Status_Text;

    LB_MODE_MANUAL:
        Manual_Mode(
            Number_Of_Switches := LB_NUMBER_OF_SWITCHES,
            Switch_Status := HMI_Manual_Switch,
            Switch_Power := LB_MANUAL_SWITCH_POWER
        );
        Mode_Target_Power := Manual_Mode.Target_Power_kW;
        HMI_Manual_Selected_kW := Manual_Mode.Target_Power_kW;
        
        IF Mode_Target_Power > 0 THEN
            Manual_Mode_Status := 'Manual control active';
        ELSE
            Manual_Mode_Status := 'Select switches to apply load';
        END_IF;
        
    LB_MODE_RECIPE:
        Recipe_Controller(
            Recipe_Enable := Master_Enable,
            Recipe_Start := HMI_Recipe_Start,
            Recipe_Pause := HMI_Recipe_Pause,
            Recipe_Abort := HMI_Recipe_Stop,
            Recipe_Steps := HMI_Recipe_Steps,
            Number_Of_Steps := HMI_Recipe_Number_Of_Steps,
            Current_Power_kW := LB_System_Status.Released_Power_kW
        );
        Mode_Target_Power := Recipe_Controller.Target_Power_kW;
        
        LB_Recipe_Status.Recipe_Running := Recipe_Controller.Recipe_Running;
        LB_Recipe_Status.Recipe_Paused := Recipe_Controller.Recipe_Paused;
        LB_Recipe_Status.Recipe_Complete := Recipe_Controller.Recipe_Complete;
        LB_Recipe_Status.Recipe_Aborted := Recipe_Controller.Recipe_Aborted;
        LB_Recipe_Status.Current_Step := Recipe_Controller.Current_Step_Number;
        LB_Recipe_Status.Current_Step_Name := Recipe_Controller.Current_Step_Name;
        LB_Recipe_Status.Current_Target_kW := Recipe_Controller.Target_Power_kW;
        LB_Recipe_Status.Step_Elapsed_Time := Recipe_Controller.Step_Elapsed_Time;
        LB_Recipe_Status.Step_Remaining_Time := Recipe_Controller.Step_Remaining_Time;
        LB_Recipe_Status.Total_Recipe_Time := Recipe_Controller.Total_Recipe_Time;
        LB_Recipe_Status.Total_Elapsed_Time := Recipe_Controller.Total_Elapsed_Time;
        LB_Recipe_Status.Total_Remaining_Time := Recipe_Controller.Total_Remaining_Time;
        LB_Recipe_Status.Recipe_Progress_Pct := Recipe_Controller.Recipe_Progress_Percent;
        LB_Recipe_Status.Status_Message := Recipe_Controller.Status_Message;
        
    LB_MODE_MAINTENANCE:
        // Call FB_Maintenance_Mode with full inputs
        Maintenance_Mode(
            Mode_Active := TRUE,
            Master_Enable := Master_Enable,
            Emergency_Active := Any_Emergency,
            Number_Of_Steps := LB_NUMBER_OF_STEPS,
            Power_Tolerance_Percent := Maint_Mode_Power_Tolerance_Percent,
            Feedback_Timeout_ms := Maint_Mode_Feedback_Timeout_ms,
            Test_Duration_Sec := Maint_Mode_Test_Duration_Sec,
            Delay_Between_Steps_ms := 1000,
            Cycle_Time_ms := 10,
            Selected_Step := Maint_Mode_Selected_Step,
            Toggle_Fan_Cmd := Maint_Mode_Toggle_Fan,
            Toggle_Step_Cmd := Maint_Mode_Toggle_Step,
            Reset_Test_Cmd := Maint_Mode_Reset_Test,
            Self_Test_Start := Maint_Mode_Self_Test_Start,
            Self_Test_Stop := Maint_Mode_Self_Test_Stop,
            Fan_Contactor_FB := IO_Fan_Contactor_FB,
            Fan_Pressure_OK := IO_Fan_Pressure_OK,
            Fan_Overload_OK := IO_Fan_Motor_Overload_OK,
            Step_Feedback := IO_Load_Contactor_FB,
            Step_Power_kW := IO_Step_Power,
            Step_Rated_Power := LB_STEP_POWER,
            Step_Quarantined := Step_Quarantined
        );
        
        // Copy maintenance status to HMI
        Maint_Mode_Self_Test_Running := Maintenance_Mode.Self_Test_Running;
        Maint_Mode_Self_Test_Complete := Maintenance_Mode.Self_Test_Complete;
        Maint_Mode_Self_Test_Current_Step := Maintenance_Mode.Self_Test_Current_Step;
        Maint_Mode_Self_Test_Timer_Sec := Maintenance_Mode.Self_Test_Timer_Sec;
        Maint_Mode_Self_Test_Pass_Count := Maintenance_Mode.Self_Test_Pass_Count;
        Maint_Mode_Self_Test_Fail_Count := Maintenance_Mode.Self_Test_Fail_Count;
        Maint_Mode_Feedback_Match := Maintenance_Mode.Feedback_Match;
        Maint_Mode_Response_Time_ms := Maintenance_Mode.Response_Time_ms;
        Maint_Mode_Power_Within_Tolerance := Maintenance_Mode.Power_Within_Tolerance;
        Maint_Mode_Status_Message := Maintenance_Mode.Status_Message;
        
        // Handle quarantine signals
        IF Maintenance_Mode.Quarantine_Step > 0 THEN
            Step_Quarantined[Maintenance_Mode.Quarantine_Step] := TRUE;
            LB_HMI_Steps[Maintenance_Mode.Quarantine_Step].Status_Quarantined := TRUE;
        END_IF;
        
        IF Maintenance_Mode.Unquarantine_Step > 0 THEN
            Step_Quarantined[Maintenance_Mode.Unquarantine_Step] := FALSE;
            LB_HMI_Steps[Maintenance_Mode.Unquarantine_Step].Status_Quarantined := FALSE;
        END_IF;

END_CASE;

// ============================================================
// APPLY DUMP LIMIT TO TARGET
// ============================================================
IF Dump_Active OR Dump_Complete THEN
    Mode_Target_Power := Gradual_Dump.Target_Power_kW;
END_IF;

// ============================================================
// LOAD CONTROLLER
// ============================================================
Load_Controller(
    Target_Power_kW := Mode_Target_Power,
    Main_Contactor_Closed := Main_Contactor_Closed,
    Step_Power_Rating := LB_STEP_POWER,
    Number_Of_Steps := LB_NUMBER_OF_STEPS,
    Step_Feedback := IO_Load_Contactor_FB,
    Measured_Total_Power := IO_Total_Power_kW,
    Step_Quarantine_Manual := Step_Quarantine_Manual,
    Step_Unquarantine_Cmd := Step_Unquarantine_Cmd,
    Maintenance_Mode := (Mode_Manager.Active_Mode = LB_MODE_MAINTENANCE),
    Manual_Step_Cmd := HMI_Manual_Step_Cmd,
    Deadband_kW := LB_AUTO_LEVEL_DEADBAND,
    Step_Up_Delay := LB_STEP_UP_DELAY,
    Step_Down_Delay := LB_STEP_DOWN_DELAY,
    Feedback_Timeout := LB_FEEDBACK_TIMEOUT,
    Enable_Feedback_Monitoring := LB_ENABLE_FEEDBACK_MONITORING,
    Power_Tolerance_Percent := LB_POWER_TOLERANCE_PERCENT,
    Power_Monitor_Delay := LB_POWER_MONITOR_DELAY,
    Enable_Power_Monitoring := LB_ENABLE_POWER_MONITORING,
    Enable := Mode_Manager.Enable_Output,
    Reset := Alarm_Reset_Pulse
);

// Update status
Status_Load := Load_Controller.Status_Text;
LB_System_Status.Released_Power_kW := Load_Controller.Released_Power_kW;
LB_System_Status.Available_Power_kW := Load_Controller.Available_Power_kW;
LB_System_Status.Rated_Total_kW := Load_Controller.Rated_Total_kW;
LB_System_Status.Active_Steps := Load_Controller.Active_Step_Count;
LB_System_Status.Quarantined_Steps := Load_Controller.Quarantined_Step_Count;

// Copy to runtime variables (only when NOT in maintenance mode)
IF Mode_Manager.Active_Mode <> LB_MODE_MAINTENANCE THEN
    FOR i := 1 TO LB_NUMBER_OF_STEPS DO
        Step_Quarantined[i] := Load_Controller.Step_Quarantined[i];
        Step_Quarantine_Feedback[i] := Load_Controller.Step_Quarantine_Feedback[i];
        Step_Cycle_Count[i] := Load_Controller.Step_Cycle_Count[i];
    END_FOR;
END_IF;

// HMI step counts
LB_HMI_Active_Count := UINT_TO_INT(Load_Controller.Active_Step_Count);
LB_HMI_Quarantined_Count := UINT_TO_INT(Load_Controller.Quarantined_Step_Count);
LB_HMI_Inactive_Count := UINT_TO_INT(LB_NUMBER_OF_STEPS) - LB_HMI_Active_Count - LB_HMI_Quarantined_Count;
LB_HMI_Total_Steps := UINT_TO_INT(LB_NUMBER_OF_STEPS);

// HMI power percentages
IF Load_Controller.Rated_Total_kW > 0.0 THEN
    LB_HMI_Released_Percent := (Load_Controller.Released_Power_kW / Load_Controller.Rated_Total_kW) * 100.0;
    LB_HMI_Available_Percent := (Load_Controller.Available_Power_kW / Load_Controller.Rated_Total_kW) * 100.0;
ELSE
    LB_HMI_Released_Percent := 0.0;
    LB_HMI_Available_Percent := 0.0;
END_IF;

// ============================================================
// IO OUTPUTS - SINGLE POINT OF CONTROL
// ============================================================
IF Mode_Manager.Active_Mode = LB_MODE_MAINTENANCE THEN
    // MAINTENANCE MODE - Use FB outputs directly
    IO_Fan_Contactor_Coil := Maintenance_Mode.Fan_Output;
    
    FOR i := 1 TO LB_NUMBER_OF_STEPS DO
        IO_Load_Contactor_Coil[i] := Maintenance_Mode.Step_Output[i];
    END_FOR;
    
    // Main contactor OFF in maintenance mode
    IO_Main_Contactor_Coil := FALSE;
    
ELSE
    // NORMAL MODES - Use normal FB outputs
    IO_Fan_Contactor_Coil := Single_Fan.Contactor_Output;
    IO_Main_Contactor_Coil := Main_Contactor.Contactor_Output;
    
    FOR i := 1 TO LB_NUMBER_OF_STEPS DO
        IO_Load_Contactor_Coil[i] := Load_Controller.Step_Coil_Cmd[i];
    END_FOR;
END_IF;

// ============================================================
// CALCULATE BAR WIDTHS FOR HMI
// ============================================================
IF LB_HMI_Total_Steps > 0 THEN
    LB_HMI_Active_Bar_Width := (INT_TO_REAL(LB_HMI_Active_Count) / INT_TO_REAL(LB_HMI_Total_Steps)) * 343.0;
    LB_HMI_Quarantine_Bar_Width := (INT_TO_REAL(LB_HMI_Quarantined_Count) / INT_TO_REAL(LB_HMI_Total_Steps)) * 343.0;
    LB_HMI_Inactive_Bar_Width := (INT_TO_REAL(LB_HMI_Inactive_Count) / INT_TO_REAL(LB_HMI_Total_Steps)) * 343.0;
ELSE
    LB_HMI_Active_Bar_Width := 0.0;
    LB_HMI_Quarantine_Bar_Width := 0.0;
    LB_HMI_Inactive_Bar_Width := 0.0;
END_IF;

// ============================================================
// UPDATE HMI STEP ARRAY
// ============================================================
FOR i := 1 TO LB_NUMBER_OF_STEPS DO
    LB_HMI_Steps[i].Step_Number := i;
    LB_HMI_Steps[i].Rated_Power_kW := LB_STEP_POWER[i];
    LB_HMI_Steps[i].Status_Active := IO_Load_Contactor_Coil[i];
    LB_HMI_Steps[i].Status_Quarantined := Step_Quarantined[i];
    LB_HMI_Steps[i].Has_Feedback := IO_Load_Contactor_FB[i];
    LB_HMI_Steps[i].Cycle_Count := Step_Cycle_Count[i];
END_FOR;

// ============================================================
// DATA LOGGER
// ============================================================
DataLogger(
    Enable := LB_LOG_ENABLE,
    USB_Log_Enable := LB_USB_LOG_ENABLE,
    Sample_Time := LB_LOG_SAMPLE_TIME,
    Buffer_Size := LB_TREND_BUFFER_SIZE,
    Power_Released := LB_System_Status.Released_Power_kW,
    Power_Target := Mode_Target_Power,
    Temp_TC1 := Temp_TC_Buffer[1],
    Temp_TC2 := Temp_TC_Buffer[2],
    Temp_TC3 := Temp_TC_Buffer[3],
    Temp_TC4 := Temp_TC_Buffer[4],
    Number_Of_TCs := LB_NUMBER_OF_TCS,
    Voltage_L1L2 := IO_Voltage_L1_L2,
    Voltage_L2L3 := IO_Voltage_L2_L3,
    Voltage_L3L1 := IO_Voltage_L3_L1,
    Current_I1 := IO_Current_L1,
    Current_I2 := IO_Current_L2,
    Current_I3 := IO_Current_L3,
    USB_Path := LB_USB_LOG_PATH
);

// ============================================================
// HOTTEST TC FOR HMI
// ============================================================
LB_HMI_Hottest_TC := UINT_TO_INT(Temperature_Monitor.Hottest_TC_Index);

// ============================================================
// HMI STATUS BAR TEXT
// ============================================================
IF Alarm_Manager.Total_Active_Count > 0 THEN
    HMI_System_Status_Text := Alarm_Manager.Status_Text;
    HMI_Alarm_Detail_Text := Alarm_Manager.Detail_Text;
ELSE
    IF System_Running THEN
        HMI_System_Status_Text := 'RUNNING';
        HMI_Alarm_Detail_Text := LB_HMI_Mode_Text;
    ELSIF System_Ready THEN
        HMI_System_Status_Text := 'READY';
        HMI_Alarm_Detail_Text := 'Select mode to start';
    ELSIF Single_Fan.Fan_Running THEN
        HMI_System_Status_Text := 'FAN RUNNING';
        HMI_Alarm_Detail_Text := Status_Fan;
    ELSIF Single_Fan.Contactor_Output THEN
        HMI_System_Status_Text := 'FAN STARTING';
        HMI_Alarm_Detail_Text := Status_Fan;
    ELSE
        HMI_System_Status_Text := 'STOPPED';
        IF NOT HMI_Master_Enable THEN
            HMI_Alarm_Detail_Text := 'Enable master to start';
        ELSIF NOT HMI_Fan_Start THEN
            HMI_Alarm_Detail_Text := 'Start fan to continue';
        ELSE
            HMI_Alarm_Detail_Text := Status_Fan;
        END_IF;
    END_IF;
END_IF;

// Emergency text
IF EMG_Immediate_Active THEN
    LB_HMI_Emergency_Text := 'IMMEDIATE E-STOP';
ELSIF EMG_Controlled_Active OR Is_Emergency_Dump THEN
    LB_HMI_Emergency_Text := 'CONTROLLED E-STOP';
ELSIF Is_Temperature_Dump THEN
    LB_HMI_Emergency_Text := 'OVER TEMPERATURE';
ELSE
    LB_HMI_Emergency_Text := '';
END_IF;
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>
